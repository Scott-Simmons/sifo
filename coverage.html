
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>archive: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">SecureSyncDrive/pkg/archive/archive.go (71.6%)</option>
				
				<option value="file1">SecureSyncDrive/pkg/encrypt/encrypt.go (63.5%)</option>
				
				<option value="file2">SecureSyncDrive/pkg/extract/extract.go (66.7%)</option>
				
				<option value="file3">SecureSyncDrive/pkg/list_files/list_files.go (81.0%)</option>
				
				<option value="file4">SecureSyncDrive/pkg/sync/sync.go (70.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package archive

// Reference: https://www.arthurkoziel.com/writing-tar-gz-files-in-go/

import (
        "archive/tar"
        "bytes"
        "compress/gzip"
        "errors"
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
)

func FileIsTar(file *os.File) (bool, error) <span class="cov8" title="1">{
        const tarHeaderSizeBytes = 512
        headerBuffer := make([]byte, tarHeaderSizeBytes)

        _, err := file.Read(headerBuffer)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return false, nil // don't throw error becuase it just means invalid tar
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Seek back to the start of the file to read it fully later
        <span class="cov8" title="1">_, err = file.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("WTF")
                return false, err
        }</span>

        <span class="cov8" title="1">tarReader := tar.NewReader(bytes.NewReader(headerBuffer))

        _, err = tarReader.Next()
        if err == io.EOF </span><span class="cov0" title="0">{
                // Empty file could be a true tar
                return true, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return false, nil // dont throw error because it just means invalid tar
        }</span>

        // If header read then its a tar
        <span class="cov8" title="1">return true, nil</span>

}

func ArchiveFolder(srcDirPath string, destTarPath string) error <span class="cov8" title="1">{
        destTar, err := os.Create(destTarPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("Could not create tarball file '%s', got error '%s'", destTarPath, err.Error()))
        }</span>
        <span class="cov8" title="1">defer destTar.Close()

        gzipWriter := gzip.NewWriter(destTar)
        defer gzipWriter.Close()

        tarWriter := tar.NewWriter(gzipWriter)
        defer tarWriter.Close()

        // Iterate through the directory tree and add everything to the tar archive
        if err := addDirToTar(tarWriter, srcDirPath, srcDirPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not add write directory to tar: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func addFileToTar(tarWriter *tar.Writer, filePath string, headerName string) error <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fileInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">header, err := tar.FileInfoHeader(fileInfo, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Need to overwrite header.Name because need complete path relative to the base directory to keep the tree structure... hence need to pass in the full path of the file and base dir. Since default fileinfo header name is just the file name not the full path.
        <span class="cov8" title="1">header.Name = headerName

        if err := tarWriter.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Copying this data into the tar writer which is chained to the gzipwriter for compression
        <span class="cov8" title="1">_, err = io.Copy(tarWriter, file)
        return err</span>
}

func addDirToTar(tarWriter *tar.Writer, baseDir string, dir string) error <span class="cov8" title="1">{
        d, err := os.Open(dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer d.Close()

        // Get file information
        fileInfo, err := d.Stat()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error getting file info:", err)
                return err
        }</span>

        // Validate if it is a directory
        <span class="cov8" title="1">if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                fmt.Println("Not a directory")
                return err
        }</span>

        // Read directory entries
        <span class="cov8" title="1">files, err := d.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                // Main logic - get relative path and full path
                fullPath := path.Join(dir, file.Name())
                relPath, _ := filepath.Rel(baseDir, fullPath)

                if file.IsDir() </span><span class="cov8" title="1">{
                        if err := addDirToTar(tarWriter, baseDir, fullPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := addFileToTar(tarWriter, fullPath, relPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package encrypt

// Ref: https://earthly.dev/blog/cryptography-encryption-in-go/

import (
        "SecureSyncDrive/pkg/archive"
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "io"
        "os"
)

func GenerateKey() ([]byte, error) <span class="cov0" title="0">{
        aes256ByteSize := 32
        key := make([]byte, aes256ByteSize)
        _, err := rand.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Generated key: %x\n", key)
        return key, nil</span>
}

func trimNewLinesFromBytes(btyes []byte) []byte <span class="cov8" title="1">{
        const newlineLF = 0x0A
        const newlineCR = 0x0D
        var cleanedData []byte
        for _, byte := range btyes </span><span class="cov8" title="1">{
                if byte != newlineLF &amp;&amp; byte != newlineCR </span><span class="cov8" title="1">{
                        cleanedData = append(cleanedData, byte)
                }</span>
        }
        <span class="cov8" title="1">return cleanedData</span>
}

// TODO: put this in another place
func ReadAES256KeyFromFile(keyFilePath string) ([]byte, error) <span class="cov8" title="1">{
        keyHex, err := os.ReadFile(keyFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">key, err := hex.DecodeString(string(trimNewLinesFromBytes(keyHex)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode hexadecimal key: %w", err)
        }</span>

        <span class="cov8" title="1">const expectedBtyes = 32

        if len(key) != expectedBtyes </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("key length must be %d bytes for AES-256 but found %d bytes", expectedBtyes, (len(key)))
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

func EncryptTarBall(tarBallToEncrypt string, encryptedTarballPath string, privateKeyPath string) error <span class="cov8" title="1">{

        key, err := ReadAES256KeyFromFile(privateKeyPath)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("Failed to read key:", err)
                return err
        }</span>

        <span class="cov8" title="1">srcFile, err := os.Open(tarBallToEncrypt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer srcFile.Close()

        // TODO: isTar has a bug in it... need to fix later for now just don't use it
        _, err = archive.FileIsTar(srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //if !isTar {
        //  return errors.New("file is not a valid tar archive")
        //}

        <span class="cov8" title="1">encryptedTarballFile, err := os.Create(encryptedTarballPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer encryptedTarballFile.Close()

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create initialisation vector and fill it with random numbers
        <span class="cov8" title="1">iv := make([]byte, aes.BlockSize)
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the IV to the start of the destination file
        <span class="cov8" title="1">if _, err := encryptedTarballFile.Write(iv); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create CBC mode cipher encrypter function
        <span class="cov8" title="1">encrypter := cipher.NewCBCEncrypter(block, iv)

        // Begin the encryption
        bufferSize := 1024 // arbitrary
        buf := make([]byte, bufferSize)
        for </span><span class="cov8" title="1">{
                // File content read into buffer of fixed length
                n, err := srcFile.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                        break</span> // EOF reached
                }

                // Pad data to be a multiple of the block size
                <span class="cov8" title="1">paddedData := pad(buf[:n], aes.BlockSize)

                // Encrypt and write to the destination file
                // Do the encryption in place, overwriting the padded data
                encrypter.CryptBlocks(paddedData, paddedData)
                if _, err := encryptedTarballFile.Write(paddedData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func pad(data []byte, blockSize int) []byte <span class="cov8" title="1">{
        padding := blockSize - len(data)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(data, padtext...)
}</span>

// TODO: Put this in another place
func Unpad(data []byte, blockSize int) ([]byte, error) <span class="cov0" title="0">{
        length := len(data)
        if length == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data length is zero")
        }</span>

        <span class="cov0" title="0">padding := data[length-1]
        if int(padding) &gt; blockSize || int(padding) &gt; length </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid padding size")
        }</span>

        <span class="cov0" title="0">for _, b := range data[length-int(padding):] </span><span class="cov0" title="0">{
                if b != padding </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid padding byte")
                }</span>
        }

        <span class="cov0" title="0">return data[:length-int(padding)], nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package extract

import (
        "archive/tar"
        "bytes"
        "compress/gzip"
        "fmt"
        "io"
        "os"
        "path/filepath"
)

func ExtractTar(tarData []byte) error <span class="cov8" title="1">{
        // assumes gzipped no matter what...
        gzipReader, err := gzip.NewReader(bytes.NewReader(tarData))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer gzipReader.Close()

        tarReader := tar.NewReader(gzipReader)

        for </span><span class="cov8" title="1">{
                header, err := tarReader.Next()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">switch header.Typeflag </span>{
                case tar.TypeDir:<span class="cov0" title="0">
                        if err := os.MkdirAll(header.Name, os.FileMode(header.Mode)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case tar.TypeReg:<span class="cov8" title="1">
                        if err := os.MkdirAll(filepath.Dir(header.Name), 0755); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">outFile, err := os.Create(header.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer outFile.Close()
                        if _, err := io.Copy(outFile, tarReader); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("Tar entry type not supported: %v", header.Typeflag)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package list_files

import (
  "encoding/json"
  "fmt"
  "log"
        "SecureSyncDrive/pkg/rpc_client"
  _ "github.com/rclone/rclone/fs/operations"
)


type listFilesRequest struct {
  FSrc   string `json:"fs"`
  Remote string `json:"remote"`
}

type GoogleDriveFile struct {
  Path     string `json:"Path"`
        Name     string `json:"Name"`
        Size     int    `json:"Size"`
        MimeType string `json:"MimeType"`
        ModTime  string `json:"ModTime"`
        IsDir    bool   `json:"IsDir"`
        ID       string `json:"ID"`
}

type FileListOutput struct {
        List []GoogleDriveFile `json:"list"`
}

// Generics don't work well in golang but would be lovely to have a generic map.
func Map(files []GoogleDriveFile, f func(GoogleDriveFile) string) []string <span class="cov8" title="1">{
        ids := make([]string, len(files))
        for i, file := range files </span><span class="cov8" title="1">{
                ids[i] = f(file)
        }</span>
        <span class="cov8" title="1">return ids</span>
}

func ListRemoteFiles(client rpc_client.RPCClient, googleDriveRemote string) ([]GoogleDriveFile, error) <span class="cov8" title="1">{
  // Assume flat structure for now no recursive list. Will be flat encrypted anyway.
  // Ref: https://github.com/rclone/rclone/blob/1901bae4ebcbc4cdd82f6bb1862d0479f3fa386e/fs/operations/rc_test.go
        if err := client.Initialize(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">const listJsonMethod = "operations/list"
        listFilesRequest := listFilesRequest {
                FSrc: googleDriveRemote,
                Remote: "",
        }
        listFilesRequestJson, err := json.Marshal(listFilesRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">out, status := client.RPC(listJsonMethod, string(listFilesRequestJson))
        if status != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error status: %d and error output: %s", status, out)
        }</span>
  <span class="cov8" title="1">var structuredOutput FileListOutput
  err = json.Unmarshal([]byte(out), &amp;structuredOutput)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error unmarshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">return structuredOutput.List, nil</span>
}

func GetGoogleDriveFileIds(files []GoogleDriveFile) []string <span class="cov8" title="1">{
  return Map(files, func(f GoogleDriveFile) string </span><span class="cov8" title="1">{ return f.ID}</span> )
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package sync

// Ref: https://rclone.org/docs/#connection-strings
// Ref: https://forum.rclone.org/t/use-rclone-golang-to-transfer-files/34983/23?page=2
// Ref: https://github.com/alankritkharbanda/rclone/blob/5975b7d27728f5ba0c3c670759fe9cc3dfb65ff2/librclone/README.md

import (
        "encoding/json"
        "fmt"
        "SecureSyncDrive/pkg/rpc_client"
        _ "github.com/rclone/rclone/backend/drive"
        _ "github.com/rclone/rclone/backend/local" // local backend and google drive backend imported to ensure they are registered. Otherwise errors out.
        _ "github.com/rclone/rclone/fs/sync"
)


type syncRequest struct {
        SrcFs string `json:"srcFs"`
        DstFs string `json:"dstFs"` // best to keep struct as PascalCase. Not accessible otherwise
}

func NewClient() (*rpc_client.RealRPCClient, error) <span class="cov0" title="0">{
        client := &amp;rpc_client.RealRPCClient{}
        return client, nil
}</span>

// NOTE: This is destructive... it makes dst look exactly like src.
func sync(client rpc_client.RPCClient, src string, dst string) error <span class="cov8" title="1">{
        if err := client.Initialize(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ref: https://github.com/rclone/rclone/blob/master/fs/sync/sync.go
        <span class="cov8" title="1">const syncMethod = "sync/sync"

        syncRequest := syncRequest{
                SrcFs: src,
                DstFs: dst,
        }

        syncRequestJson, err := json.Marshal(syncRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Println(syncRequestJson)
        fmt.Println(string(syncRequestJson))
        out, status := client.RPC(syncMethod, string(syncRequestJson))

        if status != 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("Error status: %d and error output: %s", status, out)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Success: %s\n", out)
        }</span>
        <span class="cov8" title="1">fmt.Println(out)
        fmt.Println(status)
        return nil</span>
}

// TODO: Validation
func SyncToGoogleDrive(client rpc_client.RPCClient, srcFilePath string, googleDriveFilePath string) error <span class="cov8" title="1">{
        if err := sync(client, srcFilePath, googleDriveFilePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TODO: Validation
func SyncFromGoogleDrive(client rpc_client.RPCClient, googleDriveFilePath string, localTargetDir string) error <span class="cov8" title="1">{
        if err := sync(client, googleDriveFilePath, localTargetDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
